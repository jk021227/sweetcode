"use strict";
<<<<<<< HEAD
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
=======
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
const util = __importStar(require("../util"));
/**
 * Check whatever node can be considered as simple
 * @param node the node to be evaluated.
 */
function isSimpleType(node) {
    switch (node.type) {
<<<<<<< HEAD
        case utils_1.AST_NODE_TYPES.Identifier:
        case utils_1.AST_NODE_TYPES.TSAnyKeyword:
        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:
        case utils_1.AST_NODE_TYPES.TSNeverKeyword:
        case utils_1.AST_NODE_TYPES.TSNumberKeyword:
        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:
        case utils_1.AST_NODE_TYPES.TSObjectKeyword:
        case utils_1.AST_NODE_TYPES.TSStringKeyword:
        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:
        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:
        case utils_1.AST_NODE_TYPES.TSVoidKeyword:
        case utils_1.AST_NODE_TYPES.TSNullKeyword:
        case utils_1.AST_NODE_TYPES.TSArrayType:
        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
        case utils_1.AST_NODE_TYPES.TSThisType:
        case utils_1.AST_NODE_TYPES.TSQualifiedName:
            return true;
        case utils_1.AST_NODE_TYPES.TSTypeReference:
            if (node.typeName &&
                node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&
=======
        case experimental_utils_1.AST_NODE_TYPES.Identifier:
        case experimental_utils_1.AST_NODE_TYPES.TSAnyKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSBooleanKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSNeverKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSNumberKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSObjectKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSStringKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSSymbolKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSUnknownKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSVoidKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSNullKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSArrayType:
        case experimental_utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
        case experimental_utils_1.AST_NODE_TYPES.TSThisType:
        case experimental_utils_1.AST_NODE_TYPES.TSQualifiedName:
            return true;
        case experimental_utils_1.AST_NODE_TYPES.TSTypeReference:
            if (node.typeName &&
                node.typeName.type === experimental_utils_1.AST_NODE_TYPES.Identifier &&
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                node.typeName.name === 'Array') {
                if (!node.typeParameters) {
                    return true;
                }
                if (node.typeParameters.params.length === 1) {
                    return isSimpleType(node.typeParameters.params[0]);
                }
            }
            else {
                if (node.typeParameters) {
                    return false;
                }
                return isSimpleType(node.typeName);
            }
            return false;
        default:
            return false;
    }
}
/**
 * Check if node needs parentheses
 * @param node the node to be evaluated.
 */
function typeNeedsParentheses(node) {
    switch (node.type) {
<<<<<<< HEAD
        case utils_1.AST_NODE_TYPES.TSTypeReference:
            return typeNeedsParentheses(node.typeName);
        case utils_1.AST_NODE_TYPES.TSUnionType:
        case utils_1.AST_NODE_TYPES.TSFunctionType:
        case utils_1.AST_NODE_TYPES.TSIntersectionType:
        case utils_1.AST_NODE_TYPES.TSTypeOperator:
        case utils_1.AST_NODE_TYPES.TSInferType:
        case utils_1.AST_NODE_TYPES.TSConstructorType:
            return true;
        case utils_1.AST_NODE_TYPES.Identifier:
=======
        case experimental_utils_1.AST_NODE_TYPES.TSTypeReference:
            return typeNeedsParentheses(node.typeName);
        case experimental_utils_1.AST_NODE_TYPES.TSUnionType:
        case experimental_utils_1.AST_NODE_TYPES.TSFunctionType:
        case experimental_utils_1.AST_NODE_TYPES.TSIntersectionType:
        case experimental_utils_1.AST_NODE_TYPES.TSTypeOperator:
        case experimental_utils_1.AST_NODE_TYPES.TSInferType:
            return true;
        case experimental_utils_1.AST_NODE_TYPES.Identifier:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
            return node.name === 'ReadonlyArray';
        default:
            return false;
    }
}
<<<<<<< HEAD
=======
const arrayOption = { enum: ['array', 'generic', 'array-simple'] };
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
exports.default = util.createRule({
    name: 'array-type',
    meta: {
        type: 'suggestion',
        docs: {
<<<<<<< HEAD
            description: 'Require consistently using either `T[]` or `Array<T>` for arrays',
            recommended: 'strict',
        },
        fixable: 'code',
        messages: {
            errorStringGeneric: "Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden. Use '{{className}}<{{type}}>' instead.",
            errorStringArray: "Array type using '{{className}}<{{type}}>' is forbidden. Use '{{readonlyPrefix}}{{type}}[]' instead.",
            errorStringArraySimple: "Array type using '{{className}}<{{type}}>' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}[]' instead.",
            errorStringGenericSimple: "Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden for non-simple types. Use '{{className}}<{{type}}>' instead.",
        },
        schema: {
            $defs: {
                arrayOption: {
                    enum: ['array', 'generic', 'array-simple'],
                },
            },
            prefixItems: [
                {
                    properties: {
                        default: {
                            $ref: '#/$defs/arrayOption',
                            description: 'The array type expected for mutable cases...',
                        },
                        readonly: {
                            $ref: '#/$defs/arrayOption',
                            description: 'The array type expected for readonly cases. If omitted, the value for `default` will be used.',
                        },
                    },
                    type: 'object',
                },
            ],
            type: 'array',
        },
=======
            description: 'Requires using either `T[]` or `Array<T>` for arrays',
            category: 'Stylistic Issues',
            // too opinionated to be recommended
            recommended: false,
        },
        fixable: 'code',
        messages: {
            errorStringGeneric: "Array type using '{{type}}[]' is forbidden. Use 'Array<{{type}}>' instead.",
            errorStringGenericSimple: "Array type using '{{type}}[]' is forbidden for non-simple types. Use 'Array<{{type}}>' instead.",
            errorStringArray: "Array type using 'Array<{{type}}>' is forbidden. Use '{{type}}[]' instead.",
            errorStringArraySimple: "Array type using 'Array<{{type}}>' is forbidden for simple types. Use '{{type}}[]' instead.",
        },
        schema: [
            {
                type: 'object',
                properties: {
                    default: arrayOption,
                    readonly: arrayOption,
                },
            },
        ],
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    },
    defaultOptions: [
        {
            default: 'array',
        },
    ],
    create(context, [options]) {
        var _a;
        const sourceCode = context.getSourceCode();
        const defaultOption = options.default;
        const readonlyOption = (_a = options.readonly) !== null && _a !== void 0 ? _a : defaultOption;
<<<<<<< HEAD
=======
        const isArraySimpleOption = defaultOption === 'array-simple' && readonlyOption === 'array-simple';
        const isArrayOption = defaultOption === 'array' && readonlyOption === 'array';
        const isGenericOption = defaultOption === 'generic' && readonlyOption === 'generic';
        /**
         * Check if whitespace is needed before this node
         * @param node the node to be evaluated.
         */
        function requireWhitespaceBefore(node) {
            const prevToken = sourceCode.getTokenBefore(node);
            if (!prevToken) {
                return false;
            }
            const nextToken = sourceCode.getTokenAfter(prevToken);
            if (nextToken && sourceCode.isSpaceBetweenTokens(prevToken, nextToken)) {
                return false;
            }
            return prevToken.type === experimental_utils_1.AST_TOKEN_TYPES.Identifier;
        }
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        /**
         * @param node the node to be evaluated.
         */
        function getMessageType(node) {
<<<<<<< HEAD
            if (node && isSimpleType(node)) {
                return sourceCode.getText(node);
            }
            return 'T';
        }
        return {
            TSArrayType(node) {
                const isReadonly = node.parent &&
                    node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&
                    node.parent.operator === 'readonly';
                const currentOption = isReadonly ? readonlyOption : defaultOption;
                if (currentOption === 'array' ||
                    (currentOption === 'array-simple' && isSimpleType(node.elementType))) {
                    return;
                }
                const messageId = currentOption === 'generic'
                    ? 'errorStringGeneric'
                    : 'errorStringGenericSimple';
                const errorNode = isReadonly ? node.parent : node;
                context.report({
                    node: errorNode,
                    messageId,
                    data: {
                        className: isReadonly ? 'ReadonlyArray' : 'Array',
                        readonlyPrefix: isReadonly ? 'readonly ' : '',
                        type: getMessageType(node.elementType),
                    },
                    fix(fixer) {
                        const typeNode = node.elementType;
                        const arrayType = isReadonly ? 'ReadonlyArray' : 'Array';
                        return [
                            fixer.replaceTextRange([errorNode.range[0], typeNode.range[0]], `${arrayType}<`),
                            fixer.replaceTextRange([typeNode.range[1], errorNode.range[1]], '>'),
                        ];
=======
            if (node) {
                if (node.type === experimental_utils_1.AST_NODE_TYPES.TSParenthesizedType) {
                    return getMessageType(node.typeAnnotation);
                }
                if (isSimpleType(node)) {
                    return sourceCode.getText(node);
                }
            }
            return 'T';
        }
        /**
         * @param node the node to be evaluated
         */
        function getTypeOpNodeRange(node) {
            if (!node) {
                return undefined;
            }
            const firstToken = sourceCode.getFirstToken(node);
            const nextToken = sourceCode.getTokenAfter(firstToken);
            return [firstToken.range[0], nextToken.range[0]];
        }
        return {
            TSArrayType(node) {
                if (isArrayOption ||
                    (isArraySimpleOption && isSimpleType(node.elementType))) {
                    return;
                }
                const isReadonly = node.parent &&
                    node.parent.type === experimental_utils_1.AST_NODE_TYPES.TSTypeOperator &&
                    node.parent.operator === 'readonly';
                const isReadonlyGeneric = readonlyOption === 'generic' && defaultOption !== 'generic';
                const isReadonlyArray = readonlyOption !== 'generic' && defaultOption === 'generic';
                if ((isReadonlyGeneric && !isReadonly) ||
                    (isReadonlyArray && isReadonly)) {
                    return;
                }
                const messageId = defaultOption === 'generic'
                    ? 'errorStringGeneric'
                    : 'errorStringGenericSimple';
                const typeOpNode = isReadonly ? node.parent : null;
                context.report({
                    node: isReadonly ? node.parent : node,
                    messageId,
                    data: {
                        type: getMessageType(node.elementType),
                    },
                    fix(fixer) {
                        const toFix = [
                            fixer.replaceTextRange([node.range[1] - 2, node.range[1]], '>'),
                        ];
                        const startText = requireWhitespaceBefore(node);
                        const typeOpNodeRange = getTypeOpNodeRange(typeOpNode);
                        if (typeOpNodeRange) {
                            toFix.unshift(fixer.removeRange(typeOpNodeRange));
                        }
                        else {
                            toFix.push(fixer.insertTextBefore(node, `${startText ? ' ' : ''}`));
                        }
                        toFix.push(fixer.insertTextBefore(node, `${isReadonly ? 'Readonly' : ''}Array<`));
                        if (node.elementType.type === experimental_utils_1.AST_NODE_TYPES.TSParenthesizedType) {
                            const first = sourceCode.getFirstToken(node.elementType);
                            const last = sourceCode.getLastToken(node.elementType);
                            if (!first || !last) {
                                return null;
                            }
                            toFix.push(fixer.remove(first));
                            toFix.push(fixer.remove(last));
                        }
                        return toFix;
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                    },
                });
            },
            TSTypeReference(node) {
<<<<<<< HEAD
                var _a, _b;
                if (node.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||
                    !(node.typeName.name === 'Array' ||
                        node.typeName.name === 'ReadonlyArray')) {
                    return;
                }
                const isReadonlyArrayType = node.typeName.name === 'ReadonlyArray';
                const currentOption = isReadonlyArrayType
                    ? readonlyOption
                    : defaultOption;
                if (currentOption === 'generic') {
                    return;
                }
                const readonlyPrefix = isReadonlyArrayType ? 'readonly ' : '';
                const typeParams = (_a = node.typeParameters) === null || _a === void 0 ? void 0 : _a.params;
                const messageId = currentOption === 'array'
=======
                if (isGenericOption ||
                    node.typeName.type !== experimental_utils_1.AST_NODE_TYPES.Identifier) {
                    return;
                }
                const isReadonlyArrayType = node.typeName.name === 'ReadonlyArray';
                const isArrayType = node.typeName.name === 'Array';
                if (!(isArrayType || isReadonlyArrayType) ||
                    (readonlyOption === 'generic' && isReadonlyArrayType) ||
                    (defaultOption === 'generic' && !isReadonlyArrayType)) {
                    return;
                }
                const readonlyPrefix = isReadonlyArrayType ? 'readonly ' : '';
                const typeParams = node.typeParameters && node.typeParameters.params;
                const messageId = defaultOption === 'array'
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                    ? 'errorStringArray'
                    : 'errorStringArraySimple';
                if (!typeParams || typeParams.length === 0) {
                    // Create an 'any' array
                    context.report({
                        node,
                        messageId,
                        data: {
<<<<<<< HEAD
                            className: isReadonlyArrayType ? 'ReadonlyArray' : 'Array',
                            readonlyPrefix,
=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                            type: 'any',
                        },
                        fix(fixer) {
                            return fixer.replaceText(node, `${readonlyPrefix}any[]`);
                        },
                    });
                    return;
                }
                if (typeParams.length !== 1 ||
<<<<<<< HEAD
                    (currentOption === 'array-simple' && !isSimpleType(typeParams[0]))) {
                    return;
                }
                const type = typeParams[0];
                const typeParens = typeNeedsParentheses(type);
                const parentParens = readonlyPrefix &&
                    ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSArrayType &&
                    !util.isParenthesized(node.parent.elementType, sourceCode);
                const start = `${parentParens ? '(' : ''}${readonlyPrefix}${typeParens ? '(' : ''}`;
                const end = `${typeParens ? ')' : ''}[]${parentParens ? ')' : ''}`;
=======
                    (defaultOption === 'array-simple' && !isSimpleType(typeParams[0]))) {
                    return;
                }
                const type = typeParams[0];
                const parens = typeNeedsParentheses(type);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                context.report({
                    node,
                    messageId,
                    data: {
<<<<<<< HEAD
                        className: isReadonlyArrayType ? 'ReadonlyArray' : 'Array',
                        readonlyPrefix,
=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                        type: getMessageType(type),
                    },
                    fix(fixer) {
                        return [
<<<<<<< HEAD
                            fixer.replaceTextRange([node.range[0], type.range[0]], start),
                            fixer.replaceTextRange([type.range[1], node.range[1]], end),
=======
                            fixer.replaceTextRange([node.range[0], type.range[0]], `${readonlyPrefix}${parens ? '(' : ''}`),
                            fixer.replaceTextRange([type.range[1], node.range[1]], parens ? ')[]' : '[]'),
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                        ];
                    },
                });
            },
        };
    },
});
//# sourceMappingURL=array-type.js.map