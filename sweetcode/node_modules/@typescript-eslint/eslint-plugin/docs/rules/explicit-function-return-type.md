<<<<<<< HEAD
---
description: 'Require explicit return types on functions and class methods.'
---

> üõë This file is source code, not the primary documentation location! üõë
>
> See **https://typescript-eslint.io/rules/explicit-function-return-type** for documentation.

Functions in TypeScript often don't need to be given an explicit return type annotation.
Leaving off the return type is less code to read or write and allows the compiler to infer it from the contents of the function.

However, explicit return types do make it visually more clear what type is returned by a function.
They can also speed up TypeScript type checking performance in large codebases with many large functions.

This rule enforces that functions do have an explicit return type annotation.

## Examples

<!--tabs-->

### ‚ùå Incorrect
=======
# Require explicit return types on functions and class methods (`explicit-function-return-type`)

Explicit types for function return values makes it clear to any calling code what type is returned.
This ensures that the return value is assigned to a variable of the correct type; or in the case
where there is no return value, that the calling code doesn't try to use the undefined value when it
shouldn't.

## Rule Details

This rule aims to ensure that the values returned from functions are of the expected type.

The following patterns are considered warnings:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
// Should indicate that no value is returned (void)
function test() {
  return;
}

// Should indicate that a number is returned
var fn = function () {
  return 1;
};

// Should indicate that a string is returned
var arrowFn = () => 'test';

class Test {
  // Should indicate that no value is returned (void)
  method() {
    return;
  }
}
```

<<<<<<< HEAD
### ‚úÖ Correct
=======
The following patterns are not warnings:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
// No return value should be expected (void)
function test(): void {
  return;
}

// A return value of type number
var fn = function (): number {
  return 1;
};

// A return value of type string
var arrowFn = (): string => 'test';

class Test {
  // No return value should be expected (void)
  method(): void {
    return;
  }
}
```

## Options

<<<<<<< HEAD
### Configuring in a mixed JS/TS codebase

If you are working on a codebase within which you lint non-TypeScript code (i.e. `.js`/`.mjs`/`.cjs`/`.jsx`), you should ensure that you should use [ESLint `overrides`](https://eslint.org/docs/user-guide/configuring#disabling-rules-only-for-a-group-of-files) to only enable the rule on `.ts`/`.mts`/`.cts`/`.tsx` files. If you don't, then you will get unfixable lint errors reported within `.js`/`.mjs`/`.cjs`/`.jsx` files.
=======
The rule accepts an options object with the following properties:

```ts
type Options = {
  // if true, only functions which are part of a declaration will be checked
  allowExpressions?: boolean;
  // if true, type annotations are also allowed on the variable of a function expression rather than on the function directly
  allowTypedFunctionExpressions?: boolean;
  // if true, functions immediately returning another function expression will not be checked
  allowHigherOrderFunctions?: boolean;
  // if true, concise arrow functions that start with the void keyword will not be checked
  allowConciseArrowFunctionExpressionsStartingWithVoid?: boolean;
};

const defaults = {
  allowExpressions: false,
  allowTypedFunctionExpressions: true,
  allowHigherOrderFunctions: true,
  allowConciseArrowFunctionExpressionsStartingWithVoid: true,
};
```

### Configuring in a mixed JS/TS codebase

If you are working on a codebase within which you lint non-TypeScript code (i.e. `.js`/`.jsx`), you should ensure that you should use [ESLint `overrides`](https://eslint.org/docs/user-guide/configuring#disabling-rules-only-for-a-group-of-files) to only enable the rule on `.ts`/`.tsx` files. If you don't, then you will get unfixable lint errors reported within `.js`/`.jsx` files.
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```jsonc
{
  "rules": {
    // disable the rule for all files
    "@typescript-eslint/explicit-function-return-type": "off"
  },
  "overrides": [
    {
      // enable the rule specifically for TypeScript files
<<<<<<< HEAD
      "files": ["*.ts", "*.mts", "*.cts", "*.tsx"],
      "rules": {
        "@typescript-eslint/explicit-function-return-type": "error"
=======
      "files": ["*.ts", "*.tsx"],
      "rules": {
        "@typescript-eslint/explicit-function-return-type": ["error"]
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
      }
    }
  ]
}
```

### `allowExpressions`

<<<<<<< HEAD
Examples of code for this rule with `{ allowExpressions: true }`:

<!--tabs-->

#### ‚ùå Incorrect
=======
Examples of **incorrect** code for this rule with `{ allowExpressions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
function test() {}

const fn = () => {};

export default () => {};
```

<<<<<<< HEAD
#### ‚úÖ Correct
=======
Examples of **correct** code for this rule with `{ allowExpressions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
node.addEventListener('click', () => {});

node.addEventListener('click', function () {});

const foo = arr.map(i => i * i);
```

### `allowTypedFunctionExpressions`

<<<<<<< HEAD
Examples of code for this rule with `{ allowTypedFunctionExpressions: true }`:

<!--tabs-->

#### ‚ùå Incorrect
=======
Examples of **incorrect** code for this rule with `{ allowTypedFunctionExpressions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
let arrowFn = () => 'test';

let funcExpr = function () {
  return 'test';
};

let objectProp = {
  foo: () => 1,
};
```

<<<<<<< HEAD
#### ‚úÖ Correct
=======
Examples of additional **correct** code for this rule with `{ allowTypedFunctionExpressions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
type FuncType = () => string;

let arrowFn: FuncType = () => 'test';

let funcExpr: FuncType = function() {
  return 'test';
};

let asTyped = (() => '') as () => string;
let castTyped = <() => string>(() => '');

interface ObjectType {
  foo(): number;
}
let objectProp: ObjectType = {
  foo: () => 1,
};
let objectPropAs = {
  foo: () => 1,
} as ObjectType;
let objectPropCast = <ObjectType>{
  foo: () => 1,
};

declare functionWithArg(arg: () => number);
functionWithArg(() => 1);

declare functionWithObjectArg(arg: { method: () => number });
functionWithObjectArg({
  method() {
    return 1;
  },
});
```

### `allowHigherOrderFunctions`

<<<<<<< HEAD
Examples of code for this rule with `{ allowHigherOrderFunctions: true }`:

<!--tabs-->

#### ‚ùå Incorrect
=======
Examples of **incorrect** code for this rule with `{ allowHigherOrderFunctions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
var arrowFn = () => () => {};

function fn() {
  return function () {};
}
```

<<<<<<< HEAD
#### ‚úÖ Correct
=======
Examples of **correct** code for this rule with `{ allowHigherOrderFunctions: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
var arrowFn = () => (): void => {};

function fn() {
  return function (): void {};
}
```

<<<<<<< HEAD
### `allowDirectConstAssertionInArrowFunctions`

Examples of code for this rule with `{ allowDirectConstAssertionInArrowFunctions: true }`:

<!--tabs-->

#### ‚ùå Incorrect

```ts
const func = (value: number) => ({ type: 'X', value } as any);
const func = (value: number) => ({ type: 'X', value } as Action);
```

#### ‚úÖ Correct

```ts
const func = (value: number) => ({ foo: 'bar', value } as const);
const func = () => x as const;
```

### `allowConciseArrowFunctionExpressionsStartingWithVoid`

Examples of code for this rule with `{ allowConciseArrowFunctionExpressionsStartingWithVoid: true }`:

<!--tabs-->

#### ‚ùå Incorrect
=======
### `allowConciseArrowFunctionExpressionsStartingWithVoid`

Examples of **incorrect** code for this rule with `{ allowConciseArrowFunctionExpressionsStartingWithVoid: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
var join = (a: string, b: string) => `${a}${b}`;

const log = (message: string) => {
  console.log(message);
};
```

<<<<<<< HEAD
#### ‚úÖ Correct
=======
Examples of **correct** code for this rule with `{ allowConciseArrowFunctionExpressionsStartingWithVoid: true }`:
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

```ts
var log = (message: string) => void console.log(message);
```

<<<<<<< HEAD
### `allowFunctionsWithoutTypeParameters`

Examples of code for this rule with `{ allowFunctionsWithoutTypeParameters: true }`:

<!--tabs-->

#### ‚ùå Incorrect

```ts
function foo<T>(t: T) {
  return t;
}

const bar = <T>(t: T) => t;
```

#### ‚úÖ Correct

```ts
function foo<T>(t: T): T {
  return t;
}

const bar = <T>(t: T): T => t;

const allowedFunction(x: string) {
  return x;
}

const allowedArrow = (x: string) => x;
```

### `allowedNames`

You may pass function/method names you would like this rule to ignore, like so:

```json
{
  "@typescript-eslint/explicit-function-return-type": [
    "error",
    {
      "allowedNames": ["ignoredFunctionName", "ignoredMethodName"]
    }
  ]
}
```

### `allowIIFE`

Examples of code for this rule with `{ allowIIFE: true }`:

#### ‚ùå Incorrect

```ts
var func = () => 'foo';
```

#### ‚úÖ Correct

```ts
var foo = (() => 'foo')();

var bar = (function () {
  return 'bar';
})();
```

=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
## When Not To Use It

If you don't wish to prevent calling code from using function return values in unexpected ways, then
you will not need this rule.

## Further Reading

- TypeScript [Functions](https://www.typescriptlang.org/docs/handbook/functions.html#function-types)
