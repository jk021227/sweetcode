/*
 Copyright 2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

const debug = require('debug')('istanbuljs');
const libCoverage = require('istanbul-lib-coverage');
const { MappedCoverage } = require('./mapped');
const getMapping = require('./get-mapping');
const { getUniqueKey, getOutput } = require('./transform-utils');

class SourceMapTransformer {
    constructor(finder, opts = {}) {
        this.finder = finder;
        this.baseDir = opts.baseDir || process.cwd();
<<<<<<< HEAD
        this.resolveMapping = opts.getMapping || getMapping;
=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    }

    processFile(fc, sourceMap, coverageMapper) {
        let changes = 0;

<<<<<<< HEAD
        Object.entries(fc.statementMap).forEach(([s, loc]) => {
            const hits = fc.s[s];
            const mapping = this.resolveMapping(sourceMap, loc, fc.path);
=======
        Object.keys(fc.statementMap).forEach(s => {
            const loc = fc.statementMap[s];
            const hits = fc.s[s];
            const mapping = getMapping(sourceMap, loc, fc.path);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

            if (mapping) {
                changes += 1;
                const mappedCoverage = coverageMapper(mapping.source);
                mappedCoverage.addStatement(mapping.loc, hits);
            }
        });

<<<<<<< HEAD
        Object.entries(fc.fnMap).forEach(([f, fnMeta]) => {
            const hits = fc.f[f];
            const mapping = this.resolveMapping(
                sourceMap,
                fnMeta.decl,
                fc.path
            );

            const spanMapping = this.resolveMapping(
                sourceMap,
                fnMeta.loc,
                fc.path
            );
=======
        Object.keys(fc.fnMap).forEach(f => {
            const fnMeta = fc.fnMap[f];
            const hits = fc.f[f];
            const mapping = getMapping(sourceMap, fnMeta.decl, fc.path);
            const spanMapping = getMapping(sourceMap, fnMeta.loc, fc.path);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

            if (
                mapping &&
                spanMapping &&
                mapping.source === spanMapping.source
            ) {
                changes += 1;
                const mappedCoverage = coverageMapper(mapping.source);
                mappedCoverage.addFunction(
                    fnMeta.name,
                    mapping.loc,
                    spanMapping.loc,
                    hits
                );
            }
        });

<<<<<<< HEAD
        Object.entries(fc.branchMap).forEach(([b, branchMeta]) => {
=======
        Object.keys(fc.branchMap).forEach(b => {
            const branchMeta = fc.branchMap[b];
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
            const hits = fc.b[b];
            const locs = [];
            const mappedHits = [];
            let source;
            let skip;

            branchMeta.locations.forEach((loc, i) => {
<<<<<<< HEAD
                const mapping = this.resolveMapping(sourceMap, loc, fc.path);
=======
                const mapping = getMapping(sourceMap, loc, fc.path);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                if (mapping) {
                    if (!source) {
                        source = mapping.source;
                    }

                    if (mapping.source !== source) {
                        skip = true;
                    }

                    locs.push(mapping.loc);
                    mappedHits.push(hits[i]);
                }
            });

<<<<<<< HEAD
            const locMapping = branchMeta.loc
                ? this.resolveMapping(sourceMap, branchMeta.loc, fc.path)
                : null;

=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
            if (!skip && locs.length > 0) {
                changes += 1;
                const mappedCoverage = coverageMapper(source);
                mappedCoverage.addBranch(
                    branchMeta.type,
<<<<<<< HEAD
                    locMapping ? locMapping.loc : locs[0],
=======
                    locs[0] /* XXX */,
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                    locs,
                    mappedHits
                );
            }
        });

        return changes > 0;
    }

<<<<<<< HEAD
    async transform(coverageMap) {
=======
    transform(coverageMap) {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        const uniqueFiles = {};
        const getMappedCoverage = file => {
            const key = getUniqueKey(file);
            if (!uniqueFiles[key]) {
                uniqueFiles[key] = {
                    file,
                    mappedCoverage: new MappedCoverage(file)
                };
            }

            return uniqueFiles[key].mappedCoverage;
        };

<<<<<<< HEAD
        for (const file of coverageMap.files()) {
            const fc = coverageMap.fileCoverageFor(file);
            const sourceMap = await this.finder(file, fc);

            if (sourceMap) {
                const changed = this.processFile(
                    fc,
                    sourceMap,
                    getMappedCoverage
                );
                if (!changed) {
                    debug(`File [${file}] ignored, nothing could be mapped`);
                }
            } else {
                uniqueFiles[getUniqueKey(file)] = {
                    file,
                    mappedCoverage: new MappedCoverage(fc)
                };
            }
        }
=======
        coverageMap.files().forEach(file => {
            const fc = coverageMap.fileCoverageFor(file);
            const sourceMap = this.finder(file);
            if (!sourceMap) {
                uniqueFiles[getUniqueKey(file)] = {
                    file,
                    mappedCoverage: fc
                };
                return;
            }

            const changed = this.processFile(fc, sourceMap, getMappedCoverage);
            if (!changed) {
                debug(`File [${file}] ignored, nothing could be mapped`);
            }
        });
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

        return libCoverage.createCoverageMap(getOutput(uniqueFiles));
    }
}

module.exports = {
<<<<<<< HEAD
    SourceMapTransformer
=======
    create(finder, opts) {
        return new SourceMapTransformer(finder, opts);
    }
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
};
