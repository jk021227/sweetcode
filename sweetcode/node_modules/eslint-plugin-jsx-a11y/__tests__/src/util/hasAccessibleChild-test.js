<<<<<<< HEAD
import test from 'tape';
import { elementType } from 'jsx-ast-utils';

=======
/* eslint-env jest */
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
import hasAccessibleChild from '../../../src/util/hasAccessibleChild';
import JSXElementMock from '../../../__mocks__/JSXElementMock';
import JSXAttributeMock from '../../../__mocks__/JSXAttributeMock';
import JSXExpressionContainerMock from '../../../__mocks__/JSXExpressionContainerMock';

<<<<<<< HEAD
test('hasAccessibleChild', (t) => {
  t.equal(
    hasAccessibleChild(JSXElementMock('div', []), elementType),
    false,
    'has no children and does not set dangerouslySetInnerHTML -> false',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [JSXAttributeMock('dangerouslySetInnerHTML', true)], []),
      elementType,
    ),
    true,
    'has no children and sets dangerouslySetInnerHTML -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock(
        'div',
        [],
        [{
          type: 'Literal',
          value: 'foo',
        }],
      ),
      elementType,
    ),
    true,
    'has children + Literal child -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [JSXElementMock('div', [])]),
      elementType,
    ),
    true,
    'has children + visible JSXElement child -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [{
        type: 'JSXText',
        value: 'foo',
      }]),
      elementType,
    ),
    true,
    'has children + JSText element -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXElementMock('div', [
          JSXAttributeMock('aria-hidden', true),
        ]),
      ]),
      elementType,
    ),
    false,
    'has children + hidden child JSXElement -> false',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXExpressionContainerMock({
          type: 'Identifier',
          name: 'foo',
        }),
      ]),
      elementType,
    ),
    true,
    'defined JSXExpressionContainer -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXExpressionContainerMock({
          type: 'Identifier',
          name: 'undefined',
        }),
      ]),
      elementType,
    ),
    false,
    'has children + undefined JSXExpressionContainer -> false',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [{
        type: 'Unknown',
      }]),
      elementType,
    ),
    false,
    'unknown child type -> false',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [JSXAttributeMock('children', true)], []),
      elementType,
    ),
    true,
    'children passed as a prop -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXElementMock('input', [JSXAttributeMock('type', 'hidden')]),
      ]),
      elementType,
    ),
    false,
    'has chidren -> hidden child input JSXElement -> false',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXElementMock('CustomInput', [JSXAttributeMock('type', 'hidden')]),
      ]),
      elementType,
    ),
    true,
    'has children + custom JSXElement of type hidden -> true',
  );

  t.equal(
    hasAccessibleChild(
      JSXElementMock('div', [], [
        JSXElementMock('CustomInput', [JSXAttributeMock('type', 'hidden')]),
      ]),
      () => 'input',
    ),
    false,
    'custom JSXElement mapped to input if type is hidden -> false',
  );

  t.end();
=======
describe('hasAccessibleChild', () => {
  describe('has no children and does not set dangerouslySetInnerHTML', () => {
    it('returns false', () => {
      expect(hasAccessibleChild(JSXElementMock('div', []))).toBe(false);
    });
  });


  describe('has no children and sets dangerouslySetInnerHTML', () => {
    it('Returns true', () => {
      const prop = JSXAttributeMock('dangerouslySetInnerHTML', true);
      const element = JSXElementMock('div', [prop], []);
      expect(hasAccessibleChild(element)).toBe(true);
    });
  });

  describe('has children', () => {
    it('Returns true for a Literal child', () => {
      const child = {
        type: 'Literal',
        value: 'foo',
      };
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(true);
    });

    it('Returns true for visible child JSXElement', () => {
      const child = JSXElementMock('div', []);
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(true);
    });

    it('Returns true for JSXText Element', () => {
      const child = {
        type: 'JSXText',
        value: 'foo',
      };
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(true);
    });

    it('Returns false for hidden child JSXElement', () => {
      const ariaHiddenAttr = JSXAttributeMock('aria-hidden', true);
      const child = JSXElementMock('div', [ariaHiddenAttr]);
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(false);
    });

    it('Returns true for defined JSXExpressionContainer', () => {
      const expression = {
        type: 'Identifier',
        name: 'foo',
      };
      const child = JSXExpressionContainerMock(expression);
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(true);
    });

    it('Returns false for undefined JSXExpressionContainer', () => {
      const expression = {
        type: 'Identifier',
        name: 'undefined',
      };
      const child = JSXExpressionContainerMock(expression);
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(false);
    });

    it('Returns false for unknown child type', () => {
      const child = {
        type: 'Unknown',
      };
      const element = JSXElementMock('div', [], [child]);
      expect(hasAccessibleChild(element)).toBe(false);
    });

    it('Returns true with children passed as a prop', () => {
      const children = JSXAttributeMock('children', true);
      const element = JSXElementMock('div', [children], []);
      expect(hasAccessibleChild(element)).toBe(true);
    });
  });
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
});
