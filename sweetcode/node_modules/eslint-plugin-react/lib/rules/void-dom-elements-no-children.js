/**
 * @fileoverview Prevent void elements (e.g. <img />, <br />) from receiving
 *   children
 * @author Joe Lencioni
 */

'use strict';

<<<<<<< HEAD
const has = require('hasown');

const docsUrl = require('../util/docsUrl');
const isCreateElement = require('../util/isCreateElement');
const report = require('../util/report');
=======
const has = require('has');

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

// ------------------------------------------------------------------------------
// Helpers
// ------------------------------------------------------------------------------

// Using an object here to avoid array scan. We should switch to Set once
// support is good enough.
const VOID_DOM_ELEMENTS = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  menuitem: true,
  meta: true,
  param: true,
  source: true,
  track: true,
<<<<<<< HEAD
  wbr: true,
=======
  wbr: true
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
};

function isVoidDOMElement(elementName) {
  return has(VOID_DOM_ELEMENTS, elementName);
}

<<<<<<< HEAD
=======
function errorMessage(elementName) {
  return `Void DOM element <${elementName} /> cannot receive children.`;
}

>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
const noChildrenInVoidEl = 'Void DOM element <{{element}} /> cannot receive children.';

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow void DOM elements (e.g. `<img />`, `<br />`) from receiving children',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('void-dom-elements-no-children'),
    },

    messages: {
      noChildrenInVoidEl,
    },

    schema: [],
  },

  create: (context) => ({
=======
module.exports = {
  meta: {
    docs: {
      description: 'Prevent passing of children to void DOM elements (e.g. `<br />`).',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('void-dom-elements-no-children')
    },
    schema: []
  },

  create: Components.detect((context, components, utils) => ({
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    JSXElement(node) {
      const elementName = node.openingElement.name.name;

      if (!isVoidDOMElement(elementName)) {
        // e.g. <div />
        return;
      }

      if (node.children.length > 0) {
        // e.g. <br>Foo</br>
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node,
          message: errorMessage(elementName)
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        });
      }

      const attributes = node.openingElement.attributes;

      const hasChildrenAttributeOrDanger = attributes.some((attribute) => {
        if (!attribute.name) {
          return false;
        }

        return attribute.name.name === 'children' || attribute.name.name === 'dangerouslySetInnerHTML';
      });

      if (hasChildrenAttributeOrDanger) {
        // e.g. <br children="Foo" />
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node,
          message: errorMessage(elementName)
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        });
      }
    },

    CallExpression(node) {
      if (node.callee.type !== 'MemberExpression' && node.callee.type !== 'Identifier') {
        return;
      }

<<<<<<< HEAD
      if (!isCreateElement(context, node)) {
=======
      if (!utils.isCreateElement(node)) {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        return;
      }

      const args = node.arguments;

      if (args.length < 1) {
        // React.createElement() should not crash linter
        return;
      }

<<<<<<< HEAD
      const elementName = 'value' in args[0] ? args[0].value : undefined;
=======
      const elementName = args[0].value;
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

      if (!isVoidDOMElement(elementName)) {
        // e.g. React.createElement('div');
        return;
      }

      if (args.length < 2 || args[1].type !== 'ObjectExpression') {
        return;
      }

      const firstChild = args[2];
      if (firstChild) {
        // e.g. React.createElement('br', undefined, 'Foo')
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
=======
        context.report({
          node,
          message: errorMessage(elementName)
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        });
      }

      const props = args[1].properties;

      const hasChildrenPropOrDanger = props.some((prop) => {
<<<<<<< HEAD
        if (!('key' in prop) || !prop.key || !('name' in prop.key)) {
=======
        if (!prop.key) {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
          return false;
        }

        return prop.key.name === 'children' || prop.key.name === 'dangerouslySetInnerHTML';
      });

      if (hasChildrenPropOrDanger) {
        // e.g. React.createElement('br', { children: 'Foo' })
<<<<<<< HEAD
        report(context, noChildrenInVoidEl, 'noChildrenInVoidEl', {
          node,
          data: {
            element: elementName,
          },
        });
      }
    },
  }),
=======
        context.report({
          node,
          message: errorMessage(elementName)
        });
      }
    }
  }))
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
};
