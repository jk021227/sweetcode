/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD

"use strict";

const NormalModule = require("../NormalModule");
const LazySet = require("../util/LazySet");
const LoaderDependency = require("./LoaderDependency");
const LoaderImportDependency = require("./LoaderImportDependency");

/** @typedef {import("../../declarations/LoaderContext").LoaderPluginLoaderContext} LoaderPluginLoaderContext */
/** @typedef {import("../Compilation").DepConstructor} DepConstructor */
/** @typedef {import("../Compilation").ExecuteModuleResult} ExecuteModuleResult */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Module")} Module */
/** @typedef {import("../Module").BuildInfo} BuildInfo */

/**
 * @callback ImportModuleCallback
 * @param {(Error | null)=} err error object
 * @param {any=} exports exports of the evaluated module
 */

/**
 * @typedef {object} ImportModuleOptions
 * @property {string=} layer the target layer
 * @property {string=} publicPath the target public path
 * @property {string=} baseUri target base uri
 */

class LoaderPlugin {
	/**
	 * @param {object} options options
	 */
	constructor(options = {}) {}

	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
=======
"use strict";

const LoaderDependency = require("./LoaderDependency");
const NormalModule = require("../NormalModule");

/** @typedef {import("../Module")} Module */

/**
 * @callback LoadModuleCallback
 * @param {Error=} err error object
 * @param {string=} source source code
 * @param {object=} map source map
 * @param {Module=} module loaded module if successful
 */

class LoaderPlugin {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"LoaderPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					LoaderDependency,
					normalModuleFactory
				);
<<<<<<< HEAD
				compilation.dependencyFactories.set(
					LoaderImportDependency,
					normalModuleFactory
				);
=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
			}
		);

		compiler.hooks.compilation.tap("LoaderPlugin", compilation => {
<<<<<<< HEAD
			const moduleGraph = compilation.moduleGraph;
			NormalModule.getCompilationHooks(compilation).loader.tap(
				"LoaderPlugin",
				loaderContext => {
=======
			compilation.hooks.normalModuleLoader.tap(
				"LoaderPlugin",
				(loaderContext, module) => {
					/**
					 * @param {string} request the request string to load the module from
					 * @param {LoadModuleCallback} callback callback returning the loaded module or error
					 * @returns {void}
					 */
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
					loaderContext.loadModule = (request, callback) => {
						const dep = new LoaderDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
<<<<<<< HEAD
							/** @type {DepConstructor} */ (dep.constructor)
=======
							dep.constructor
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
						);
						if (factory === undefined) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${dep.constructor.name}`
								)
							);
						}
<<<<<<< HEAD
						compilation.buildQueue.increaseParallelism();
						compilation.handleModuleCreation(
							{
								factory,
								dependencies: [dep],
								originModule:
									/** @type {NormalModule} */
									(loaderContext._module),
								context: loaderContext.context,
								recursive: false
							},
							err => {
								compilation.buildQueue.decreaseParallelism();
								if (err) {
									return callback(err);
								}
								const referencedModule = moduleGraph.getModule(dep);
								if (!referencedModule) {
									return callback(new Error("Cannot load the module"));
								}
								if (referencedModule.getNumberOfErrors() > 0) {
									return callback(
										new Error("The loaded module contains errors")
									);
								}
								const moduleSource = referencedModule.originalSource();
								if (!moduleSource) {
									return callback(
										new Error(
											"The module created for a LoaderDependency must have an original source"
										)
									);
								}
								let map;
								let source;
								if (moduleSource.sourceAndMap) {
									const sourceAndMap = moduleSource.sourceAndMap();
									map = sourceAndMap.map;
									source = sourceAndMap.source;
								} else {
									map = moduleSource.map();
									source = moduleSource.source();
								}
								const fileDependencies = new LazySet();
								const contextDependencies = new LazySet();
								const missingDependencies = new LazySet();
								const buildDependencies = new LazySet();
								referencedModule.addCacheDependencies(
									fileDependencies,
									contextDependencies,
									missingDependencies,
									buildDependencies
								);

								for (const d of fileDependencies) {
									loaderContext.addDependency(d);
								}
								for (const d of contextDependencies) {
									loaderContext.addContextDependency(d);
								}
								for (const d of missingDependencies) {
									loaderContext.addMissingDependency(d);
								}
								for (const d of buildDependencies) {
									loaderContext.addBuildDependency(d);
								}
								return callback(
									null,
									source,
									/** @type {object | null} */ (map),
									referencedModule
								);
							}
						);
					};

					/**
					 * @param {string} request the request string to load the module from
					 * @param {ImportModuleOptions} options options
					 * @param {ImportModuleCallback} callback callback returning the exports
					 * @returns {void}
					 */
					const importModule = (request, options, callback) => {
						const dep = new LoaderImportDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
							/** @type {DepConstructor} */ (dep.constructor)
						);
						if (factory === undefined) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${dep.constructor.name}`
								)
							);
						}
						compilation.buildQueue.increaseParallelism();
						compilation.handleModuleCreation(
							{
								factory,
								dependencies: [dep],
								originModule:
									/** @type {NormalModule} */
									(loaderContext._module),
								contextInfo: {
									issuerLayer: options.layer
								},
								context: loaderContext.context,
								connectOrigin: false,
								checkCycle: true
							},
							err => {
								compilation.buildQueue.decreaseParallelism();
								if (err) {
									return callback(err);
								}
								const referencedModule = moduleGraph.getModule(dep);
								if (!referencedModule) {
									return callback(new Error("Cannot load the module"));
								}
								compilation.executeModule(
									referencedModule,
									{
										entryOptions: {
											baseUri: options.baseUri,
											publicPath: options.publicPath
										}
									},
									(err, result) => {
										if (err) return callback(err);
										const {
											fileDependencies,
											contextDependencies,
											missingDependencies,
											buildDependencies,
											cacheable,
											assets,
											exports
										} = /** @type {ExecuteModuleResult} */ (result);
										for (const d of fileDependencies) {
											loaderContext.addDependency(d);
										}
										for (const d of contextDependencies) {
											loaderContext.addContextDependency(d);
										}
										for (const d of missingDependencies) {
											loaderContext.addMissingDependency(d);
										}
										for (const d of buildDependencies) {
											loaderContext.addBuildDependency(d);
										}
										if (cacheable === false) loaderContext.cacheable(false);
										for (const [name, { source, info }] of assets) {
											const buildInfo =
												/** @type {BuildInfo} */
												(
													/** @type {NormalModule} */ (loaderContext._module)
														.buildInfo
												);
											if (!buildInfo.assets) {
												buildInfo.assets = Object.create(null);
												buildInfo.assetsInfo = new Map();
											}
											/** @type {NonNullable<BuildInfo["assets"]>} */
											(buildInfo.assets)[name] = source;
											/** @type {NonNullable<BuildInfo["assetsInfo"]>} */
											(buildInfo.assetsInfo).set(name, info);
										}
										callback(null, exports);
									}
								);
							}
						);
					};

					// eslint-disable-next-line no-warning-comments
					// @ts-ignore Overloading doesn't work
					loaderContext.importModule = (request, options, callback) => {
						if (!callback) {
							return new Promise((resolve, reject) => {
								importModule(request, options || {}, (err, result) => {
									if (err) reject(err);
									else resolve(result);
								});
							});
						}
						return importModule(request, options || {}, callback);
					};
=======
						compilation.semaphore.release();
						compilation.addModuleDependencies(
							module,
							[
								{
									factory,
									dependencies: [dep]
								}
							],
							true,
							"lm",
							true,
							err => {
								compilation.semaphore.acquire(() => {
									if (err) {
										return callback(err);
									}
									if (!dep.module) {
										return callback(new Error("Cannot load the module"));
									}
									// TODO consider removing this in webpack 5
									if (dep.module instanceof NormalModule && dep.module.error) {
										return callback(dep.module.error);
									}
									if (!dep.module._source) {
										throw new Error(
											"The module created for a LoaderDependency must have a property _source"
										);
									}
									let source, map;
									const moduleSource = dep.module._source;
									if (moduleSource.sourceAndMap) {
										const sourceAndMap = moduleSource.sourceAndMap();
										map = sourceAndMap.map;
										source = sourceAndMap.source;
									} else {
										map = moduleSource.map();
										source = moduleSource.source();
									}
									if (dep.module.buildInfo.fileDependencies) {
										for (const d of dep.module.buildInfo.fileDependencies) {
											loaderContext.addDependency(d);
										}
									}
									if (dep.module.buildInfo.contextDependencies) {
										for (const d of dep.module.buildInfo.contextDependencies) {
											loaderContext.addContextDependency(d);
										}
									}
									return callback(null, source, map, dep.module);
								});
							}
						);
					};
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
				}
			);
		});
	}
}
module.exports = LoaderPlugin;
