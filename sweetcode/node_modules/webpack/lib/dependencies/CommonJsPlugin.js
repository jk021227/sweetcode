/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const SelfModuleFactory = require("../SelfModuleFactory");
const Template = require("../Template");
const CommonJsExportsDependency = require("./CommonJsExportsDependency");
const CommonJsFullRequireDependency = require("./CommonJsFullRequireDependency");
const CommonJsRequireContextDependency = require("./CommonJsRequireContextDependency");
const CommonJsRequireDependency = require("./CommonJsRequireDependency");
const CommonJsSelfReferenceDependency = require("./CommonJsSelfReferenceDependency");
const ModuleDecoratorDependency = require("./ModuleDecoratorDependency");
const RequireHeaderDependency = require("./RequireHeaderDependency");
const RequireResolveContextDependency = require("./RequireResolveContextDependency");
const RequireResolveDependency = require("./RequireResolveDependency");
const RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");
const RuntimeRequirementsDependency = require("./RuntimeRequirementsDependency");

const CommonJsExportsParserPlugin = require("./CommonJsExportsParserPlugin");
const CommonJsImportsParserPlugin = require("./CommonJsImportsParserPlugin");

const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC
} = require("../ModuleTypeConstants");
const {
	evaluateToIdentifier,
	toConstantDependency
} = require("../javascript/JavascriptParserHelpers");
const CommonJsExportRequireDependency = require("./CommonJsExportRequireDependency");

/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import("../Compilation")} Compilation */
/** @typedef {import("../Compiler")} Compiler */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../Module").BuildInfo} BuildInfo */
/** @typedef {import("../javascript/JavascriptParser")} Parser */

const PLUGIN_NAME = "CommonJsPlugin";

class CommonJsPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
=======
"use strict";
const ConstDependency = require("./ConstDependency");
const CommonJsRequireDependency = require("./CommonJsRequireDependency");
const CommonJsRequireContextDependency = require("./CommonJsRequireContextDependency");
const RequireResolveDependency = require("./RequireResolveDependency");
const RequireResolveContextDependency = require("./RequireResolveContextDependency");
const RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");
const RequireHeaderDependency = require("./RequireHeaderDependency");

const NullFactory = require("../NullFactory");

const RequireResolveDependencyParserPlugin = require("./RequireResolveDependencyParserPlugin");
const CommonJsRequireDependencyParserPlugin = require("./CommonJsRequireDependencyParserPlugin");

const ParserHelpers = require("../ParserHelpers");

class CommonJsPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"CommonJsPlugin",
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					CommonJsRequireDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireDependency,
					new CommonJsRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
<<<<<<< HEAD
					CommonJsFullRequireDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsFullRequireDependency,
					new CommonJsFullRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
					CommonJsRequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireContextDependency,
					new CommonJsRequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveDependency,
					new RequireResolveDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveContextDependency,
					new RequireResolveContextDependency.Template()
				);

<<<<<<< HEAD
=======
				compilation.dependencyFactories.set(
					RequireResolveHeaderDependency,
					new NullFactory()
				);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
				compilation.dependencyTemplates.set(
					RequireResolveHeaderDependency,
					new RequireResolveHeaderDependency.Template()
				);

<<<<<<< HEAD
=======
				compilation.dependencyFactories.set(
					RequireHeaderDependency,
					new NullFactory()
				);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
				compilation.dependencyTemplates.set(
					RequireHeaderDependency,
					new RequireHeaderDependency.Template()
				);

<<<<<<< HEAD
				compilation.dependencyTemplates.set(
					CommonJsExportsDependency,
					new CommonJsExportsDependency.Template()
				);

				compilation.dependencyFactories.set(
					CommonJsExportRequireDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsExportRequireDependency,
					new CommonJsExportRequireDependency.Template()
				);

				const selfFactory = new SelfModuleFactory(compilation.moduleGraph);

				compilation.dependencyFactories.set(
					CommonJsSelfReferenceDependency,
					selfFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsSelfReferenceDependency,
					new CommonJsSelfReferenceDependency.Template()
				);

				compilation.dependencyFactories.set(
					ModuleDecoratorDependency,
					selfFactory
				);
				compilation.dependencyTemplates.set(
					ModuleDecoratorDependency,
					new ModuleDecoratorDependency.Template()
				);

				compilation.hooks.runtimeRequirementInModule
					.for(RuntimeGlobals.harmonyModuleDecorator)
					.tap(PLUGIN_NAME, (module, set) => {
						set.add(RuntimeGlobals.module);
						set.add(RuntimeGlobals.requireScope);
					});

				compilation.hooks.runtimeRequirementInModule
					.for(RuntimeGlobals.nodeModuleDecorator)
					.tap(PLUGIN_NAME, (module, set) => {
						set.add(RuntimeGlobals.module);
						set.add(RuntimeGlobals.requireScope);
					});

				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.harmonyModuleDecorator)
					.tap(PLUGIN_NAME, (chunk, set) => {
						compilation.addRuntimeModule(
							chunk,
							new HarmonyModuleDecoratorRuntimeModule()
						);
					});

				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.nodeModuleDecorator)
					.tap(PLUGIN_NAME, (chunk, set) => {
						compilation.addRuntimeModule(
							chunk,
							new NodeModuleDecoratorRuntimeModule()
						);
					});

				/**
				 * @param {Parser} parser parser parser
				 * @param {JavascriptParserOptions} parserOptions parserOptions
				 * @returns {void}
				 */
				const handler = (parser, parserOptions) => {
					if (parserOptions.commonjs !== undefined && !parserOptions.commonjs)
						return;
					parser.hooks.typeof
						.for("module")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(parser, JSON.stringify("object"))
						);

					parser.hooks.expression
						.for("require.main")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(
								parser,
								`${RuntimeGlobals.moduleCache}[${RuntimeGlobals.entryModuleId}]`,
								[RuntimeGlobals.moduleCache, RuntimeGlobals.entryModuleId]
							)
						);
					parser.hooks.expression
						.for(RuntimeGlobals.moduleLoaded)
						.tap(PLUGIN_NAME, expr => {
							/** @type {BuildInfo} */
							(parser.state.module.buildInfo).moduleConcatenationBailout =
								RuntimeGlobals.moduleLoaded;
							const dep = new RuntimeRequirementsDependency([
								RuntimeGlobals.moduleLoaded
							]);
							dep.loc = /** @type {DependencyLocation} */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						});

					parser.hooks.expression
						.for(RuntimeGlobals.moduleId)
						.tap(PLUGIN_NAME, expr => {
							/** @type {BuildInfo} */
							(parser.state.module.buildInfo).moduleConcatenationBailout =
								RuntimeGlobals.moduleId;
							const dep = new RuntimeRequirementsDependency([
								RuntimeGlobals.moduleId
							]);
							dep.loc = /** @type {DependencyLocation} */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						});

					parser.hooks.evaluateIdentifier.for("module.hot").tap(
						PLUGIN_NAME,
						evaluateToIdentifier("module.hot", "module", () => ["hot"], null)
					);

					new CommonJsImportsParserPlugin(parserOptions).apply(parser);
					new CommonJsExportsParserPlugin(compilation.moduleGraph).apply(
						parser
					);
				};

				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)
					.tap(PLUGIN_NAME, handler);
=======
				const handler = (parser, parserOptions) => {
					if (parserOptions.commonjs !== undefined && !parserOptions.commonjs)
						return;

					const requireExpressions = [
						"require",
						"require.resolve",
						"require.resolveWeak"
					];
					for (let expression of requireExpressions) {
						parser.hooks.typeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.toConstantDependency(
									parser,
									JSON.stringify("function")
								)
							);
						parser.hooks.evaluateTypeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToString("function")
							);
						parser.hooks.evaluateIdentifier
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToIdentifier(expression, true)
							);
					}

					parser.hooks.evaluateTypeof
						.for("module")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));
					parser.hooks.assign.for("require").tap("CommonJsPlugin", expr => {
						// to not leak to global "require", we need to define a local require here.
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						parser.scope.definitions.add("require");
						return true;
					});
					parser.hooks.canRename
						.for("require")
						.tap("CommonJsPlugin", () => true);
					parser.hooks.rename.for("require").tap("CommonJsPlugin", expr => {
						// define the require variable. It's still undefined, but not "not defined".
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						return false;
					});
					parser.hooks.typeof.for("module").tap("CommonJsPlugin", () => true);
					parser.hooks.evaluateTypeof
						.for("exports")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));

					new CommonJsRequireDependencyParserPlugin(options).apply(parser);
					new RequireResolveDependencyParserPlugin(options).apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CommonJsPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("CommonJsPlugin", handler);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
			}
		);
	}
}
<<<<<<< HEAD

class HarmonyModuleDecoratorRuntimeModule extends RuntimeModule {
	constructor() {
		super("harmony module decorator");
	}

	/**
	 * @returns {string | null} runtime code
	 */
	generate() {
		const { runtimeTemplate } = /** @type {Compilation} */ (this.compilation);
		return Template.asString([
			`${
				RuntimeGlobals.harmonyModuleDecorator
			} = ${runtimeTemplate.basicFunction("module", [
				"module = Object.create(module);",
				"if (!module.children) module.children = [];",
				"Object.defineProperty(module, 'exports', {",
				Template.indent([
					"enumerable: true,",
					`set: ${runtimeTemplate.basicFunction("", [
						"throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);"
					])}`
				]),
				"});",
				"return module;"
			])};`
		]);
	}
}

class NodeModuleDecoratorRuntimeModule extends RuntimeModule {
	constructor() {
		super("node module decorator");
	}

	/**
	 * @returns {string | null} runtime code
	 */
	generate() {
		const { runtimeTemplate } = /** @type {Compilation} */ (this.compilation);
		return Template.asString([
			`${RuntimeGlobals.nodeModuleDecorator} = ${runtimeTemplate.basicFunction(
				"module",
				[
					"module.paths = [];",
					"if (!module.children) module.children = [];",
					"return module;"
				]
			)};`
		]);
	}
}

=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
module.exports = CommonJsPlugin;
