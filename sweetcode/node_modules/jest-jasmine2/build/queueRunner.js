'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = queueRunner;

<<<<<<< HEAD
var _jestUtil = require('jest-util');

=======
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
var _PCancelable = _interopRequireDefault(require('./PCancelable'));

var _pTimeout = _interopRequireDefault(require('./pTimeout'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

<<<<<<< HEAD
var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

=======
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
var Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

function queueRunner(options) {
  const token = new _PCancelable.default((onCancel, resolve) => {
    onCancel(resolve);
  });

  const mapper = ({fn, timeout, initError = new Error()}) => {
    let promise = new Promise(resolve => {
<<<<<<< HEAD
      const next = function (...args) {
=======
      const next = function next(...args) {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        const err = args[0];

        if (err) {
          options.fail.apply(null, args);
        }

        resolve();
      };

<<<<<<< HEAD
      next.fail = function (...args) {
=======
      next.fail = function(...args) {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        options.fail.apply(null, args);
        resolve();
      };

      try {
        fn.call(options.userContext, next);
      } catch (e) {
        options.onException(e);
        resolve();
      }
    });
    promise = Promise.race([promise, token]);

    if (!timeout) {
      return promise;
    }

    const timeoutMs = timeout();
    return (0, _pTimeout.default)(
      promise,
      timeoutMs,
      options.clearTimeout,
      options.setTimeout,
      () => {
        initError.message =
          'Timeout - Async callback was not invoked within the ' +
<<<<<<< HEAD
          (0, _jestUtil.formatTime)(timeoutMs) +
          ' timeout specified by jest.setTimeout.';
=======
          timeoutMs +
          'ms timeout specified by jest.setTimeout.';
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
        initError.stack = initError.message + initError.stack;
        options.onException(initError);
      }
    );
  };

  const result = options.queueableFns.reduce(
    (promise, fn) => promise.then(() => mapper(fn)),
    Promise.resolve()
  );
  return {
    cancel: token.cancel.bind(token),
    catch: result.catch.bind(result),
    then: result.then.bind(result)
  };
}
