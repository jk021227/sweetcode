'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD
exports.setState =
  exports.setMatchers =
  exports.getState =
  exports.getMatchers =
  exports.INTERNAL_MATCHER_FLAG =
    void 0;

var _asymmetricMatchers = require('./asymmetricMatchers');

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

=======
exports.setMatchers = exports.getMatchers = exports.setState = exports.getState = exports.INTERNAL_MATCHER_FLAG = void 0;

var _asymmetricMatchers = require('./asymmetricMatchers');

>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
// Global matchers object holds the list of available matchers and
// the state, that can hold matcher specific values that change over time.
const JEST_MATCHERS_OBJECT = Symbol.for('$$jest-matchers-object'); // Notes a built-in/internal Jest matcher.
// Jest may override the stack trace of Errors thrown by internal matchers.

const INTERNAL_MATCHER_FLAG = Symbol.for('$$jest-internal-matcher');
exports.INTERNAL_MATCHER_FLAG = INTERNAL_MATCHER_FLAG;

if (!global.hasOwnProperty(JEST_MATCHERS_OBJECT)) {
<<<<<<< HEAD
  const defaultState = {
    assertionCalls: 0,
    expectedAssertionsNumber: null,
    isExpectingAssertions: false,
    suppressedErrors: [] // errors that are not thrown immediately.
  };
  Object.defineProperty(global, JEST_MATCHERS_OBJECT, {
    value: {
      matchers: Object.create(null),
      state: defaultState
=======
  Object.defineProperty(global, JEST_MATCHERS_OBJECT, {
    value: {
      matchers: Object.create(null),
      state: {
        assertionCalls: 0,
        expectedAssertionsNumber: null,
        isExpectingAssertions: false,
        suppressedErrors: [] // errors that are not thrown immediately.
      }
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    }
  });
}

const getState = () => global[JEST_MATCHERS_OBJECT].state;

exports.getState = getState;

const setState = state => {
  Object.assign(global[JEST_MATCHERS_OBJECT].state, state);
};

exports.setState = setState;

const getMatchers = () => global[JEST_MATCHERS_OBJECT].matchers;

exports.getMatchers = getMatchers;

const setMatchers = (matchers, isInternal, expect) => {
  Object.keys(matchers).forEach(key => {
    const matcher = matchers[key];
    Object.defineProperty(matcher, INTERNAL_MATCHER_FLAG, {
      value: isInternal
    });

    if (!isInternal) {
      // expect is defined
      class CustomMatcher extends _asymmetricMatchers.AsymmetricMatcher {
        constructor(inverse = false, ...sample) {
<<<<<<< HEAD
          super(sample, inverse);
        }

        asymmetricMatch(other) {
          const {pass} = matcher.call(
            this.getMatcherContext(),
            other,
            ...this.sample
          );
=======
          super(sample);
          this.inverse = inverse;
        }

        asymmetricMatch(other) {
          const _ref = matcher(other, ...this.sample),
            pass = _ref.pass;

>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
          return this.inverse ? !pass : pass;
        }

        toString() {
          return `${this.inverse ? 'not.' : ''}${key}`;
        }

        getExpectedType() {
          return 'any';
        }

        toAsymmetricMatcher() {
<<<<<<< HEAD
          return `${this.toString()}<${this.sample.map(String).join(', ')}>`;
        }
      }

      Object.defineProperty(expect, key, {
        configurable: true,
        enumerable: true,
        value: (...sample) => new CustomMatcher(false, ...sample),
        writable: true
      });
      Object.defineProperty(expect.not, key, {
        configurable: true,
        enumerable: true,
        value: (...sample) => new CustomMatcher(true, ...sample),
        writable: true
      });
=======
          return `${this.toString()}<${this.sample.join(', ')}>`;
        }
      }

      expect[key] = (...sample) => new CustomMatcher(false, ...sample);

      if (!expect.not) {
        expect.not = {};
      }

      expect.not[key] = (...sample) => new CustomMatcher(true, ...sample);
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    }
  });
  Object.assign(global[JEST_MATCHERS_OBJECT].matchers, matchers);
};

exports.setMatchers = setMatchers;
