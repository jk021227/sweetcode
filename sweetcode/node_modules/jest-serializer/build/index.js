'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD
exports.default = void 0;
exports.deserialize = deserialize;
exports.readFileSync = readFileSync;
exports.serialize = serialize;
exports.writeFileSync = writeFileSync;

function _v() {
  const data = require('v8');

  _v = function () {
=======
exports.deserialize = deserialize;
exports.serialize = serialize;
exports.readFileSync = readFileSync;
exports.writeFileSync = writeFileSync;
exports.default = void 0;

function _fs() {
  const data = _interopRequireDefault(require('fs'));

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _v() {
  const data = _interopRequireDefault(require('v8'));

  _v = function _v() {
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
    return data;
  };

  return data;
}

<<<<<<< HEAD
function fs() {
  const data = _interopRequireWildcard(require('graceful-fs'));

  fs = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
=======
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// TODO: Remove this
/// <reference path="../v8.d.ts" />
// JSON and V8 serializers are both stable when it comes to compatibility. The
// current JSON specification is well defined in RFC 8259, and V8 ensures that
// the versions are compatible by encoding the serialization version in the own
// generated buffer.
<<<<<<< HEAD
// In memory functions.
function deserialize(buffer) {
  return (0, _v().deserialize)(buffer);
}

function serialize(content) {
  return (0, _v().serialize)(content);
} // Synchronous filesystem functions.

function readFileSync(filePath) {
  return (0, _v().deserialize)(fs().readFileSync(filePath));
}

function writeFileSync(filePath, content) {
  return fs().writeFileSync(filePath, (0, _v().serialize)(content));
=======
const JS_TYPE = '__$t__';
const JS_VALUE = '__$v__';
const JS_VF = '__$f__';

function replacer(_key, value) {
  // NaN cannot be in a switch statement, because NaN !== NaN.
  if (Number.isNaN(value)) {
    return {
      [JS_TYPE]: 'n'
    };
  }

  switch (value) {
    case undefined:
      return {
        [JS_TYPE]: 'u'
      };

    case +Infinity:
      return {
        [JS_TYPE]: '+'
      };

    case -Infinity:
      return {
        [JS_TYPE]: '-'
      };
  }

  switch (value && value.constructor) {
    case Date:
      return {
        [JS_TYPE]: 'd',
        [JS_VALUE]: value.getTime()
      };

    case RegExp:
      return {
        [JS_TYPE]: 'r',
        [JS_VALUE]: value.source,
        [JS_VF]: value.flags
      };

    case Set:
      return {
        [JS_TYPE]: 's',
        [JS_VALUE]: Array.from(value)
      };

    case Map:
      return {
        [JS_TYPE]: 'm',
        [JS_VALUE]: Array.from(value)
      };

    case Buffer:
      return {
        [JS_TYPE]: 'b',
        [JS_VALUE]: value.toString('latin1')
      };
  }

  return value;
}

function reviver(_key, value) {
  if (!value || (typeof value !== 'object' && !value.hasOwnProperty(JS_TYPE))) {
    return value;
  }

  switch (value[JS_TYPE]) {
    case 'u':
      return undefined;

    case 'n':
      return NaN;

    case '+':
      return +Infinity;

    case '-':
      return -Infinity;

    case 'd':
      return new Date(value[JS_VALUE]);

    case 'r':
      return new RegExp(value[JS_VALUE], value[JS_VF]);

    case 's':
      return new Set(value[JS_VALUE]);

    case 'm':
      return new Map(value[JS_VALUE]);

    case 'b':
      return Buffer.from(value[JS_VALUE], 'latin1');
  }

  return value;
}

function jsonStringify(content) {
  // Not pretty, but the ES JSON spec says that "toJSON" will be called before
  // getting into your replacer, so we have to remove them beforehand. See
  // https://www.ecma-international.org/ecma-262/#sec-serializejsonproperty
  // section 2.b for more information.
  const dateToJSON = Date.prototype.toJSON;
  const bufferToJSON = Buffer.prototype.toJSON;
  /* eslint-disable no-extend-native */

  try {
    // @ts-ignore intentional removal of "toJSON" property.
    Date.prototype.toJSON = undefined; // @ts-ignore intentional removal of "toJSON" property.

    Buffer.prototype.toJSON = undefined;
    return JSON.stringify(content, replacer);
  } finally {
    Date.prototype.toJSON = dateToJSON;
    Buffer.prototype.toJSON = bufferToJSON;
  }
  /* eslint-enable no-extend-native */
}

function jsonParse(content) {
  return JSON.parse(content, reviver);
} // In memory functions.

function deserialize(buffer) {
  return _v().default.deserialize
    ? _v().default.deserialize(buffer)
    : jsonParse(buffer.toString('utf8'));
}

function serialize(content) {
  return _v().default.serialize
    ? _v().default.serialize(content)
    : Buffer.from(jsonStringify(content));
} // Synchronous filesystem functions.

function readFileSync(filePath) {
  return _v().default.deserialize
    ? _v().default.deserialize(_fs().default.readFileSync(filePath))
    : jsonParse(_fs().default.readFileSync(filePath, 'utf8'));
}

function writeFileSync(filePath, content) {
  return _v().default.serialize
    ? _fs().default.writeFileSync(filePath, _v().default.serialize(content))
    : _fs().default.writeFileSync(filePath, jsonStringify(content), 'utf8');
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
}

var _default = {
  deserialize,
  readFileSync,
  serialize,
  writeFileSync
};
exports.default = _default;
