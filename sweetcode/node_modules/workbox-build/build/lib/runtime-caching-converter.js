"use strict";
<<<<<<< HEAD
=======

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
<<<<<<< HEAD
Object.defineProperty(exports, "__esModule", { value: true });
exports.runtimeCachingConverter = void 0;
const common_tags_1 = require("common-tags");
const errors_1 = require("./errors");
const stringify_without_comments_1 = require("./stringify-without-comments");
/**
 * Given a set of options that configures runtime caching behavior, convert it
 * to the equivalent Workbox method calls.
 *
 * @param {ModuleRegistry} moduleRegistry
 * @param {Object} options See
 *        https://developers.google.com/web/tools/workbox/modules/workbox-build#generateSW-runtimeCaching
=======
const ol = require('common-tags').oneLine;

const errors = require('./errors');

const stringifyWithoutComments = require('./stringify-without-comments');
/**
 * Given a set of options that configures `sw-toolbox`'s behavior, convert it
 * into a string that would configure equivalent `workbox-sw` behavior.
 *
 * @param {Object} options See
 *        https://googlechromelabs.github.io/sw-toolbox/api.html#options
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
 * @return {string} A JSON string representing the equivalent options.
 *
 * @private
 */
<<<<<<< HEAD
function getOptionsString(moduleRegistry, options = {}) {
    const plugins = [];
    const handlerOptions = {};
    for (const optionName of Object.keys(options)) {
        if (options[optionName] === undefined) {
            continue;
        }
        switch (optionName) {
            // Using a library here because JSON.stringify won't handle functions.
            case 'plugins': {
                plugins.push(...options.plugins.map(stringify_without_comments_1.stringifyWithoutComments));
                break;
            }
            // These are the option properties that we want to pull out, so that
            // they're passed to the handler constructor.
            case 'cacheName':
            case 'networkTimeoutSeconds':
            case 'fetchOptions':
            case 'matchOptions': {
                handlerOptions[optionName] = options[optionName];
                break;
            }
            // The following cases are all shorthands for creating a plugin with a
            // given configuration.
            case 'backgroundSync': {
                const name = options.backgroundSync.name;
                const plugin = moduleRegistry.use('workbox-background-sync', 'BackgroundSyncPlugin');
                let pluginCode = `new ${plugin}(${JSON.stringify(name)}`;
                if (options.backgroundSync.options) {
                    pluginCode += `, ${(0, stringify_without_comments_1.stringifyWithoutComments)(options.backgroundSync.options)}`;
                }
                pluginCode += `)`;
                plugins.push(pluginCode);
                break;
            }
            case 'broadcastUpdate': {
                const channelName = options.broadcastUpdate.channelName;
                const opts = Object.assign({ channelName }, options.broadcastUpdate.options);
                const plugin = moduleRegistry.use('workbox-broadcast-update', 'BroadcastUpdatePlugin');
                plugins.push(`new ${plugin}(${(0, stringify_without_comments_1.stringifyWithoutComments)(opts)})`);
                break;
            }
            case 'cacheableResponse': {
                const plugin = moduleRegistry.use('workbox-cacheable-response', 'CacheableResponsePlugin');
                plugins.push(`new ${plugin}(${(0, stringify_without_comments_1.stringifyWithoutComments)(options.cacheableResponse)})`);
                break;
            }
            case 'expiration': {
                const plugin = moduleRegistry.use('workbox-expiration', 'ExpirationPlugin');
                plugins.push(`new ${plugin}(${(0, stringify_without_comments_1.stringifyWithoutComments)(options.expiration)})`);
                break;
            }
            case 'precacheFallback': {
                const plugin = moduleRegistry.use('workbox-precaching', 'PrecacheFallbackPlugin');
                plugins.push(`new ${plugin}(${(0, stringify_without_comments_1.stringifyWithoutComments)(options.precacheFallback)})`);
                break;
            }
            case 'rangeRequests': {
                const plugin = moduleRegistry.use('workbox-range-requests', 'RangeRequestsPlugin');
                // There are no configuration options for the constructor.
                plugins.push(`new ${plugin}()`);
                break;
            }
            default: {
                throw new Error(
                // In the default case optionName is typed as 'never'.
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `${errors_1.errors['bad-runtime-caching-config']} ${optionName}`);
            }
        }
    }
    if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {
        const optionsString = JSON.stringify(handlerOptions).slice(1, -1);
        return (0, common_tags_1.oneLine) `{
      ${optionsString ? optionsString + ',' : ''}
      plugins: [${plugins.join(', ')}]
    }`;
    }
    else {
        return '';
    }
}
function runtimeCachingConverter(moduleRegistry, runtimeCaching) {
    return runtimeCaching
        .map((entry) => {
        const method = entry.method || 'GET';
        if (!entry.urlPattern) {
            throw new Error(errors_1.errors['urlPattern-is-required']);
        }
        if (!entry.handler) {
            throw new Error(errors_1.errors['handler-is-required']);
        }
        if (entry.options &&
            entry.options.networkTimeoutSeconds &&
            entry.handler !== 'NetworkFirst') {
            throw new Error(errors_1.errors['invalid-network-timeout-seconds']);
        }
        // urlPattern might be a string, a RegExp object, or a function.
        // If it's a string, it needs to be quoted.
        const matcher = typeof entry.urlPattern === 'string'
            ? JSON.stringify(entry.urlPattern)
            : entry.urlPattern;
        const registerRoute = moduleRegistry.use('workbox-routing', 'registerRoute');
        if (typeof entry.handler === 'string') {
            const optionsString = getOptionsString(moduleRegistry, entry.options);
            const handler = moduleRegistry.use('workbox-strategies', entry.handler);
            const strategyString = `new ${handler}(${optionsString})`;
            return `${registerRoute}(${matcher.toString()}, ${strategyString}, '${method}');\n`;
        }
        else if (typeof entry.handler === 'function') {
            return `${registerRoute}(${matcher.toString()}, ${entry.handler.toString()}, '${method}');\n`;
        }
        // '' will be filtered out.
        return '';
    })
        .filter((entry) => Boolean(entry));
}
exports.runtimeCachingConverter = runtimeCachingConverter;
=======


function getOptionsString(options = {}) {
  let plugins = [];

  if (options.plugins) {
    // Using libs because JSON.stringify won't handle functions.
    plugins = options.plugins.map(stringifyWithoutComments);
    delete options.plugins;
  } // Pull handler-specific config from the options object, since they are
  // not directly used to construct a Plugin instance. If set, need to be
  // passed as options to the handler constructor instead.


  const handlerOptionKeys = ['cacheName', 'networkTimeoutSeconds', 'fetchOptions', 'matchOptions'];
  const handlerOptions = {};

  for (var _i = 0; _i < handlerOptionKeys.length; _i++) {
    const key = handlerOptionKeys[_i];

    if (key in options) {
      handlerOptions[key] = options[key];
      delete options[key];
    }
  }

  const pluginsMapping = {
    backgroundSync: 'workbox.backgroundSync.Plugin',
    broadcastUpdate: 'workbox.broadcastUpdate.Plugin',
    expiration: 'workbox.expiration.Plugin',
    cacheableResponse: 'workbox.cacheableResponse.Plugin'
  };

  var _arr = Object.entries(options);

  for (var _i2 = 0; _i2 < _arr.length; _i2++) {
    const _arr$_i = (0, _slicedToArray2.default)(_arr[_i2], 2),
          pluginName = _arr$_i[0],
          pluginConfig = _arr$_i[1];

    // Ensure that we have some valid configuration to pass to Plugin().
    if (Object.keys(pluginConfig).length === 0) {
      continue;
    }

    const pluginString = pluginsMapping[pluginName];

    if (!pluginString) {
      throw new Error(`${errors['bad-runtime-caching-config']} ${pluginName}`);
    }

    let pluginCode;

    switch (pluginName) {
      // Special case logic for plugins that have a required parameter, and then
      // an additional optional config parameter.
      case 'backgroundSync':
        {
          const name = pluginConfig.name;
          pluginCode = `new ${pluginString}(${JSON.stringify(name)}`;

          if ('options' in pluginConfig) {
            pluginCode += `, ${stringifyWithoutComments(pluginConfig.options)}`;
          }

          pluginCode += `)`;
          break;
        }

      case 'broadcastUpdate':
        {
          const channelName = pluginConfig.channelName;
          const opts = Object.assign({
            channelName
          }, pluginConfig.options);
          pluginCode = `new ${pluginString}(${stringifyWithoutComments(opts)})`;
          break;
        }
      // For plugins that just pass in an Object to the constructor, like
      // expiration and cacheableResponse

      default:
        {
          pluginCode = `new ${pluginString}(${stringifyWithoutComments(pluginConfig)})`;
        }
    }

    plugins.push(pluginCode);
  }

  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {
    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);
    return ol`{
      ${optionsString ? optionsString + ',' : ''}
      plugins: [${plugins.join(', ')}]
    }`;
  } else {
    return '';
  }
}

module.exports = (runtimeCaching = []) => {
  return runtimeCaching.map(entry => {
    const method = entry.method || 'GET';

    if (!entry.urlPattern) {
      throw new Error(errors['urlPattern-is-required']);
    }

    if (!entry.handler) {
      throw new Error(errors['handler-is-required']);
    } // This validation logic is a bit too gnarly for joi, so it's manually
    // implemented here.


    if (entry.options && entry.options.networkTimeoutSeconds && entry.handler !== 'NetworkFirst') {
      throw new Error(errors['invalid-network-timeout-seconds']);
    } // urlPattern might be a string, a RegExp object, or a function.
    // If it's a string, it needs to be quoted.


    const matcher = typeof entry.urlPattern === 'string' ? JSON.stringify(entry.urlPattern) : entry.urlPattern;

    if (typeof entry.handler === 'string') {
      const optionsString = getOptionsString(entry.options || {});
      const strategyString = `new workbox.strategies.${entry.handler}(${optionsString})`;
      return `workbox.routing.registerRoute(` + `${matcher}, ${strategyString}, '${method}');\n`;
    } else if (typeof entry.handler === 'function') {
      return `workbox.routing.registerRoute(` + `${matcher}, ${entry.handler}, '${method}');\n`;
    }
  }).filter(entry => Boolean(entry)); // Remove undefined map() return values.
};
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
