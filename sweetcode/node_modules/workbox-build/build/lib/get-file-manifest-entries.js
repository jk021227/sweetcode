"use strict";
<<<<<<< HEAD
/*
  Copyright 2021 Google LLC
=======

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/*
  Copyright 2018 Google LLC
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
<<<<<<< HEAD
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileManifestEntries = void 0;
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("./errors");
const get_composite_details_1 = require("./get-composite-details");
const get_file_details_1 = require("./get-file-details");
const get_string_details_1 = require("./get-string-details");
const transform_manifest_1 = require("./transform-manifest");
async function getFileManifestEntries({ additionalManifestEntries, dontCacheBustURLsMatching, globDirectory, globFollow, globIgnores, globPatterns = [], globStrict, manifestTransforms, maximumFileSizeToCacheInBytes, modifyURLPrefix, templatedURLs, }) {
    const warnings = [];
    const allFileDetails = new Map();
    try {
        for (const globPattern of globPatterns) {
            const { globbedFileDetails, warning } = (0, get_file_details_1.getFileDetails)({
=======
const assert = require('assert');

const path = require('path');

const errors = require('./errors');

const filterFiles = require('./filter-files');

const getCompositeDetails = require('./get-composite-details');

const getFileDetails = require('./get-file-details');

const getStringDetails = require('./get-string-details');

module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    dontCacheBustURLsMatching,
    globDirectory,
    globFollow,
    globIgnores,
    globPatterns,
    globStrict,
    manifestTransforms,
    maximumFileSizeToCacheInBytes,
    modifyURLPrefix,
    swDest,
    templatedURLs
  }) {
    const warnings = []; // Initialize to an empty array so that we can still pass something to
    // filterFiles() and get a normalized output.

    let fileDetails = [];
    const fileSet = new Set();

    if (globDirectory) {
      if (swDest) {
        // Ensure that we ignore the SW file we're eventually writing to disk.
        globIgnores.push(`**/${path.basename(swDest)}`);
      }

      try {
        fileDetails = globPatterns.reduce((accumulated, globPattern) => {
          const globbedFileDetails = getFileDetails({
            globDirectory,
            globFollow,
            globIgnores,
            globPattern,
            globStrict
          });
          globbedFileDetails.forEach(fileDetails => {
            if (fileSet.has(fileDetails.file)) {
              return;
            }

            fileSet.add(fileDetails.file);
            accumulated.push(fileDetails);
          });
          return accumulated;
        }, []);
      } catch (error) {
        // If there's an exception thrown while globbing, then report
        // it back as a warning, and don't consider it fatal.
        warnings.push(error.message);
      }
    }

    if (templatedURLs) {
      var _arr = Object.keys(templatedURLs);

      for (var _i = 0; _i < _arr.length; _i++) {
        let url = _arr[_i];
        assert(!fileSet.has(url), errors['templated-url-matches-glob']);
        const dependencies = templatedURLs[url];

        if (Array.isArray(dependencies)) {
          const details = dependencies.reduce((previous, globPattern) => {
            try {
              const globbedFileDetails = getFileDetails({
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
                globDirectory,
                globFollow,
                globIgnores,
                globPattern,
<<<<<<< HEAD
                globStrict,
            });
            if (warning) {
                warnings.push(warning);
            }
            for (const details of globbedFileDetails) {
                if (details && !allFileDetails.has(details.file)) {
                    allFileDetails.set(details.file, details);
                }
            }
        }
    }
    catch (error) {
        // If there's an exception thrown while globbing, then report
        // it back as a warning, and don't consider it fatal.
        if (error instanceof Error && error.message) {
            warnings.push(error.message);
        }
    }
    if (templatedURLs) {
        for (const url of Object.keys(templatedURLs)) {
            (0, assert_1.default)(!allFileDetails.has(url), errors_1.errors['templated-url-matches-glob']);
            const dependencies = templatedURLs[url];
            if (Array.isArray(dependencies)) {
                const details = dependencies.reduce((previous, globPattern) => {
                    try {
                        const { globbedFileDetails, warning } = (0, get_file_details_1.getFileDetails)({
                            globDirectory,
                            globFollow,
                            globIgnores,
                            globPattern,
                            globStrict,
                        });
                        if (warning) {
                            warnings.push(warning);
                        }
                        return previous.concat(globbedFileDetails);
                    }
                    catch (error) {
                        const debugObj = {};
                        debugObj[url] = dependencies;
                        throw new Error(`${errors_1.errors['bad-template-urls-asset']} ` +
                            `'${globPattern}' from '${JSON.stringify(debugObj)}':\n` +
                            `${error instanceof Error ? error.toString() : ''}`);
                    }
                }, []);
                if (details.length === 0) {
                    throw new Error(`${errors_1.errors['bad-template-urls-asset']} The glob ` +
                        `pattern '${dependencies.toString()}' did not match anything.`);
                }
                allFileDetails.set(url, (0, get_composite_details_1.getCompositeDetails)(url, details));
            }
            else if (typeof dependencies === 'string') {
                allFileDetails.set(url, (0, get_string_details_1.getStringDetails)(url, dependencies));
            }
        }
    }
    const transformedManifest = await (0, transform_manifest_1.transformManifest)({
        additionalManifestEntries,
        dontCacheBustURLsMatching,
        manifestTransforms,
        maximumFileSizeToCacheInBytes,
        modifyURLPrefix,
        fileDetails: Array.from(allFileDetails.values()),
    });
    transformedManifest.warnings.push(...warnings);
    return transformedManifest;
}
exports.getFileManifestEntries = getFileManifestEntries;
=======
                globStrict
              });
              return previous.concat(globbedFileDetails);
            } catch (error) {
              const debugObj = {};
              debugObj[url] = dependencies;
              throw new Error(`${errors['bad-template-urls-asset']} ` + `'${globPattern}' from '${JSON.stringify(debugObj)}':\n` + error);
            }
          }, []);
          fileDetails.push(getCompositeDetails(url, details));
        } else if (typeof dependencies === 'string') {
          fileDetails.push(getStringDetails(url, dependencies));
        }
      }
    }

    const filteredFiles = filterFiles({
      fileDetails,
      maximumFileSizeToCacheInBytes,
      modifyURLPrefix,
      dontCacheBustURLsMatching,
      manifestTransforms
    });

    if (warnings.length > 0) {
      filteredFiles.warnings.push(...warnings);
    }

    return filteredFiles;
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
>>>>>>> 8aded176e2bf64ab331edd712b5a251ef6940ffa
