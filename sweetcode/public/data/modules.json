[
  {
    "id": 1,
    "name": "Binary Trees",
    "description": {
      "keyProperties": "Each node has at most two children (left and right). The left child is always smaller than the parent node, and the right child is always larger. It can be empty, with just one node, or grow to be very large!",
      "yassifiedExample": "In Tree Town, every squirrel only has two kids, and each kid only has two kids. Maybe they’re super organized or just like keeping their tree neat and tidy. Even like this, after five generations, you could end up with 64 little squirrels running around! Talk about a bustling family tree!",
      "leetcodeQuestions": [
        "LeetCode 94: Binary Tree Inorder Traversal",
        "LeetCode 100: Same Tree"
      ],
      "codeExample": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}"
    }
  },
  {
    "id": 2,
    "name": "AVL Trees",
    "description": {
      "keyProperties": "It’s a self-balancing binary search tree. For every node, the height difference between the left and right subtrees is at most one. When a new scroll is added, the tree will perform rotations to stay balanced.",
      "yassifiedExample": "Imagine the wise owl doing yoga! An AVL tree is like that, making sure every branch is perfectly balanced. If one side starts to lean too much, the owl swoops in and does a little twist to even things out. Balance is key in keeping Tree Town peaceful!",
      "leetcodeQuestions": ["LeetCode 1382: Balance a Binary Search Tree"],
      "codeExample": "class AVLNode {\n    int key, height;\n    AVLNode left, right;\n    AVLNode(int d) { key = d; height = 1; }\n}"
    }
  },
  {
    "id": 3,
    "name": "Red-Black Trees",
    "description": {
      "keyProperties": "Each node is colored either red or black. The root and leaves (NIL) are always black. No red node can have red children (no two reds in a row).",
      "yassifiedExample": "In Tree Town, the villagers decided to have a color party! Each tree node gets to wear either a snazzy red or a classy black outfit. But to keep things stylish, no two red nodes can hang out together. It’s all about keeping the party balanced while having fun!",
      "leetcodeQuestions": [
        "LeetCode 430: Flatten a Multilevel Doubly Linked List"
      ],
      "codeExample": "class RBNode {\n    int data;\n    RBNode left, right, parent;\n    boolean color;\n    RBNode(int data) { this.data = data; }\n}"
    }
  },
  {
    "id": 4,
    "name": "Searching & Traversals",
    "description": {
      "keyProperties": "Traversal is how you visit all nodes in a tree. There are different methods: in-order, pre-order, and post-order. Each method gives a different view of the tree’s scrolls.",
      "yassifiedExample": "Think of it like a treasure hunt in Timberland Forest! In-order is like finding scrolls in alphabetical order, while pre-order is like marking the map before you dig. Post-order? That’s when you check the whole area before you leave! Every search method brings a unique treasure-finding strategy!",
      "leetcodeQuestions": [
        "LeetCode 94: Binary Tree Inorder Traversal",
        "LeetCode 144: Binary Tree Preorder Traversal",
        "LeetCode 145: Binary Tree Postorder Traversal"
      ],
      "codeExample": "void inorderTraversal(TreeNode root) {\n    if (root != null) {\n        inorderTraversal(root.left);\n        System.out.print(root.val + \" \");\n        inorderTraversal(root.right);\n    }\n}"
    }
  },
  {
    "id": 5,
    "name": "Tree Operations",
    "description": {
      "keyProperties": "Insertion adds a new node to the tree. Deletion removes a node and reorganizes the tree. Both operations need to maintain the tree's properties.",
      "yassifiedExample": "In Tree Town, the villagers are always planting new saplings or sometimes removing old branches. When a new scroll comes in, they need to make space by carefully placing it in the right spot. And if a scroll goes missing? They’ll prune the tree to make sure it stays in tip-top shape!",
      "leetcodeQuestions": [
        "LeetCode 701: Insert into a Binary Search Tree",
        "LeetCode 450: Delete Node in a BST"
      ],
      "codeExample": "TreeNode insert(TreeNode root, int key) {\n    if (root == null) return new TreeNode(key);\n    if (key < root.val) root.left = insert(root.left, key);\n    else root.right = insert(root.right, key);\n    return root;\n}"
    }
  },
  {
    "id": 7,
    "name": "Segment Trees",
    "description": {
      "keyProperties": "Segment trees allow for efficient range queries and updates. They are built from an array and can handle various types of queries like sum, min, and max. Useful for answering multiple range queries quickly.",
      "yassifiedExample": "In Tree Town, imagine a magical tree that can tell you the total number of acorns collected over any time period! The villagers can just ask this tree to reveal the secrets of their acorn collection, and it tells them right away. It's like having a super speedy assistant!",
      "leetcodeQuestions": ["LeetCode 307: Range Sum Query - Mutable"],
      "codeExample": "class SegmentTree {\n    int[] tree;\n    SegmentTree(int[] arr) { /* Build tree */ }\n    int query(int l, int r) { /* Query range sum */ }\n}"
    }
  },
  {
    "id": 8,
    "name": "Trie Trees",
    "description": {
      "keyProperties": "A trie is a special type of tree used to store associative data structures. It is especially used for strings and allows for quick look-up of words. Each node represents a character.",
      "yassifiedExample": "Think of a trie tree as the village's giant book of names! Each branch leads to a character, and together they spell out names of all the villagers. If you want to find a name, just follow the branches until you reach your treasure - the full name!",
      "leetcodeQuestions": ["LeetCode 208: Implement Trie (Prefix Tree)"],
      "codeExample": "class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEndOfWord = false;\n}\n\nclass Trie {\n    TrieNode root = new TrieNode();\n    void insert(String word) { /* Insert word */ }\n}"
    }
  },
  {
    "id": 9,
    "name": "Binary Search Trees",
    "description": {
      "keyProperties": "In a binary search tree, each node has a key greater than all keys in its left subtree and less than those in its right subtree. This structure allows for efficient searching, insertion, and deletion.",
      "yassifiedExample": "Imagine a tree where every fruit is organized by size! If you want a big apple, you go right; for a smaller one, you head left. This way, the villagers can quickly find exactly what they're looking for without climbing every branch!",
      "leetcodeQuestions": [
        "LeetCode 98: Validate Binary Search Tree",
        "LeetCode 235: Lowest Common Ancestor of a Binary Search Tree"
      ],
      "codeExample": "boolean isBST(TreeNode node, Integer min, Integer max) {\n    if (node == null) return true;\n    if (node.val <= min || node.val >= max) return false;\n    return isBST(node.left, min, node.val) && isBST(node.right, node.val, max);\n}"
    }
  },
  {
    "id": 10,
    "name": "B-Trees",
    "description": {
      "keyProperties": "B-trees are balanced tree data structures that maintain sorted data and allow searches, sequential access, insertions, and deletions in logarithmic time. They are often used in databases and file systems.",
      "yassifiedExample": "Picture a massive library with many rooms! Each room can hold a bunch of scrolls, and each room is connected to others like a superhighway of knowledge. B-trees help the villagers find their way through all those rooms, making sure no one gets lost in the stacks!",
      "leetcodeQuestions": [],
      "codeExample": "class BTree {\n    int[] keys;\n    BTree[] children;\n    int minDegree;\n    boolean isLeaf;\n    void splitChild(int i) { /* Split a child node */ }\n}"
    }
  }
]
